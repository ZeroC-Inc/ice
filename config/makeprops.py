#!/usr/bin/env python3
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#

import os
import sys
import shutil
import signal
import time

from xml.sax import make_parser
from xml.sax.handler import feature_namespaces
from xml.sax.handler import ContentHandler
from xml.sax import SAXException

from xml.dom.minidom import parse

progname = os.path.basename(sys.argv[0])
contentHandler = None
propertyClasses = {}

commonPreamble = "// Copyright (c) ZeroC, Inc. All rights reserved."

commonPreamble = (
    commonPreamble
    + "\n\n"
    + "// Generated by "
    + progname
    + " from file %(inputFile)s, "
    + time.ctime()
)
commonPreamble = (
    commonPreamble
    + """

// IMPORTANT: Do not edit this file -- any edits made here will be lost!
"""
)

cppHeaderPreamble = (
    commonPreamble
    + """
#ifndef ICE_INTERNAL_%(classname)s_H
#define ICE_INTERNAL_%(classname)s_H

#include <string>

namespace IceInternal
{

struct Property
{
    const char* pattern;
    bool usesRegex;
    const char* defaultValue;
    bool deprecated;

    Property(const char* n, bool r, const char* dv, bool d) :
        pattern(n),
        usesRegex(r),
        defaultValue(dv),
        deprecated(d)
    {
    }

    Property() = delete;
};

struct PropertyArray
{
    const Property* properties;
    const int length;

    PropertyArray(const Property* p, size_t len) :
        properties(p),
        length(static_cast<int>(len))
    {
    }
};

class %(classname)s
{
public:

"""
)

cppHeaderPostamble = """
    static const PropertyArray validProps[];
    static const char* clPropNames[];
};

}

#endif
"""

cppSrcPreamble = (
    commonPreamble
    + """
#include "%(classname)s.h"

"""
)

javaPreamble = (
    commonPreamble
    + """
package com.zeroc.IceInternal;

public final class %(classname)s
{
"""
)

csPreamble = (
    commonPreamble
    + """
namespace Ice.Internal;

public sealed class %(classname)s
{
"""
)

jsPreamble = (
    commonPreamble
    + """
/* eslint comma-dangle: "off" */
/* eslint array-bracket-newline: "off" */
/* eslint no-useless-escape: "off" */

const Ice = require("../Ice/Property").Ice;
const %(classname)s = {};
const Property = Ice.Property;
"""
)

jsEpilogue = """
Ice.%(classname)s = %(classname)s;
module.exports.Ice = Ice;
"""


def usage():
    global progname
    print(sys.stderr, "Usage: " + progname + " [--{cpp|java|csharp|js} file]")


def progError(msg):
    global progname
    print(sys.stderr, progname + ": " + msg)


#
# Currently the processing of PropertyNames.xml is going to take place
# in two parts. One is using DOM to extract the property 'classes' such
# as 'proxy', 'objectadapter', etc. The other part uses SAX to create
# the language mapping source code.
#


class PropertyClass:
    def __init__(self, prefixOnly, childProperties):
        self.prefixOnly = prefixOnly
        self.childProperties = childProperties

    def getChildren(self):
        return self.childProperties

    def isPrefixOnly(self):
        return self.prefixOnly

    def __repr__(self):
        return repr((repr(self.prefixOnly), repr(self.childProperties)))


def initPropertyClasses(filename):
    doc = parse(filename)
    propertyClassNodes = doc.getElementsByTagName("class")
    global propertyClasses
    propertyClasses = {}
    for n in propertyClassNodes:
        className = n.attributes["name"].nodeValue
        classType = n.attributes["prefix-only"].nodeValue
        properties = []
        for a in n.childNodes:
            if a.localName == "suffix" and a.hasAttributes():
                """Convert minidom maps to hash tables """
                attributeMap = {}
                for i in range(0, a.attributes.length):
                    attributeMap[a.attributes.item(i).name] = a.attributes.item(i).value
                properties.append(attributeMap)

        propertyClasses[className] = PropertyClass(
            classType.lower() == "true", properties
        )


#
# SAX part.
#


def handler(sigNum, frame):
    """Installed as signal handler. Should cause an files that are in
    use to be closed and removed"""
    global contentHandler
    contentHandler.cleanup()
    sys.exit(128 + sigNum)


class UnknownElementException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class PropertyHandler(ContentHandler):
    def __init__(self, inputFile, className):
        self.start = False
        self.inputFile = inputFile
        self.className = className
        self.currentSection = None
        self.sectionPropertyCount = 0
        self.sections = []
        self.cmdLineOptions = []

    def cleanup(self):
        """Needs to be overridden in derived class"""
        pass

    def startFiles(self):
        """Needs to be overridden in derived class"""
        pass

    def closeFiles(self):
        """Needs to be overridden in derived class"""
        pass

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        """Needs to be overridden in derived class"""
        pass

    def newSection(self, sectionName):
        """Needs to be overridden in derived class"""
        pass

    def moveFiles(self, location):
        """Needs to be overridden in derived class"""
        pass

    def handleNewSection(self, sectionName, noCmdLine):
        self.currentSection = sectionName
        self.sectionPropertyCount = 0
        if noCmdLine == "false":
            self.cmdLineOptions.append(sectionName)
        self.sections.append(sectionName)
        self.newSection()

    def handleProperty(self, propertyName, usesRegex, defaultValue, deprecated):
        self.propertyImpl(propertyName, usesRegex, defaultValue, deprecated)

    def startElement(self, name, attrs):
        if name == "properties":
            self.start = True
            self.startFiles()
            return

        if not self.start:
            return

        if name == "section":
            noCmdLine = attrs.get("noCmdLine", "false")
            self.handleNewSection(attrs.get("name"), noCmdLine)

        elif name == "property":
            propertyName = attrs.get("name", None)
            if "class" in attrs:
                c = propertyClasses[attrs["class"]]
                for p in c.getChildren():
                    assert propertyName is not None
                    assert propertyName != ""
                    t = dict(p)
                    t["name"] = "%s.%s" % (propertyName, p["name"])
                    self.startElement(name, t)
                if c.isPrefixOnly():
                    return

            usesRegex = "[any]" in propertyName
            deprecated = attrs.get("deprecated", "false").lower() == "true"
            defaultValue = attrs.get("default", None) or ""
            self.handleProperty(propertyName, usesRegex, defaultValue, deprecated)

    def endElement(self, name):
        if name == "properties":
            self.closeFiles()
        elif name == "section":
            self.closeSection()


class CppPropertyHandler(PropertyHandler):
    def __init__(self, inputFile, c):
        PropertyHandler.__init__(self, inputFile, c)
        self.hFile = None
        self.cppFile = None

    def cleanup(self):
        if self.hFile is not None:
            self.hFile.close()
            if os.path.exists(self.className + ".h"):
                os.remove(self.className + ".h")
        if self.cppFile is not None:
            self.cppFile.close()
            if os.path.exists(self.className + ".cpp"):
                os.remove(self.className + ".cpp")

    def startFiles(self):
        self.hFile = open(self.className + ".h", "w")
        self.cppFile = open(self.className + ".cpp", "w")
        self.hFile.write(
            cppHeaderPreamble
            % {"inputFile": self.inputFile, "classname": self.className}
        )
        self.cppFile.write(
            cppSrcPreamble % {"inputFile": self.inputFile, "classname": self.className}
        )

    def closeFiles(self):
        self.hFile.write(cppHeaderPostamble % {"classname": self.className})
        self.cppFile.write(
            "const IceInternal::PropertyArray "
            "IceInternal::%(classname)s::validProps[] =\n"
            % {"classname": self.className}
        )

        self.cppFile.write("{\n")
        for s in self.sections:
            self.cppFile.write("    %sProps,\n" % s)
        self.cppFile.write("    IceInternal::PropertyArray(0,0)\n")
        self.cppFile.write("};\n\n")

        self.cppFile.write(
            "const char* IceInternal::%(classname)s::clPropNames[] =\n"
            % {"classname": self.className}
        )
        self.cppFile.write("{\n")
        for s in self.cmdLineOptions:
            self.cppFile.write('    "%s",\n' % s)
        self.cppFile.write("    0\n")
        self.cppFile.write("};\n")
        self.hFile.close()
        self.cppFile.close()

    def fix(self, propertyName):
        return propertyName.replace("[any]", "*")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"

        propertyLine = 'IceInternal::Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=self.fix(name) if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )

        self.cppFile.write(f"    {propertyLine},\n")

    def newSection(self):
        self.hFile.write(
            "    static const PropertyArray %sProps;\n" % self.currentSection
        )
        self.cppFile.write(
            "const IceInternal::Property %sPropsData[] =\n" % self.currentSection
        )
        self.cppFile.write("{\n")

    def closeSection(self):
        self.cppFile.write("};\n")
        self.cppFile.write(
            """
const IceInternal::PropertyArray
    IceInternal::%(className)s::%(section)sProps(%(section)sPropsData,
                                                sizeof(%(section)sPropsData)/sizeof(%(section)sPropsData[0]));

"""
            % {"className": self.className, "section": self.currentSection}
        )

    def moveFiles(self, location):
        dest = os.path.join(location, "cpp", "src", "Ice")
        if os.path.exists(os.path.join(dest, self.className + ".h")):
            os.remove(os.path.join(dest, self.className + ".h"))
        if os.path.exists(os.path.join(dest, self.className + ".cpp")):
            os.remove(os.path.join(dest, self.className + ".cpp"))
        shutil.move(self.className + ".h", dest)
        shutil.move(self.className + ".cpp", dest)


class JavaPropertyHandler(PropertyHandler):
    def __init__(self, inputFile, c):
        PropertyHandler.__init__(self, inputFile, c)
        self.srcFile = None

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists(self.className + ".java"):
                os.remove(self.className + ".java")

    def startFiles(self):
        self.srcFile = open(self.className + ".java", "w")
        self.srcFile.write(
            javaPreamble % {"inputFile": self.inputFile, "classname": self.className}
        )

    def closeFiles(self):
        self.srcFile.write("    public static final Property[] validProps[] =\n")

        self.srcFile.write("    {\n")
        for s in self.sections:
            self.srcFile.write("        %sProps,\n" % s)
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n")

        self.srcFile.write("\n    public static final String clPropNames[] =\n")
        self.srcFile.write("    {\n")
        for s in self.cmdLineOptions:
            self.srcFile.write('        "%s",\n' % s)
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n")
        self.srcFile.write("}\n")
        self.srcFile.close()

    def fix(self, propertyName):
        #
        # The Java property strings are actually regexp's that will be passed to Java's regexp facility.
        #
        return propertyName.replace(".", r"\\.").replace("[any]", r"[^\\s]+")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"
        line = 'new Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=self.fix(name) if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )
        self.srcFile.write(f"        {line},\n")

    def newSection(self):
        self.srcFile.write(
            "    public static final Property %sProps[] =\n" % self.currentSection
        )
        self.srcFile.write("    {\n")

    def closeSection(self):
        self.srcFile.write("        null\n")
        self.srcFile.write("    };\n\n")

    def moveFiles(self, location):
        dest = os.path.join(
            location,
            "java",
            "src",
            "Ice",
            "src",
            "main",
            "java",
            "com",
            "zeroc",
            "IceInternal",
        )
        if os.path.exists(os.path.join(dest, self.className + ".java")):
            os.remove(os.path.join(dest, self.className + ".java"))
        shutil.move(self.className + ".java", dest)


class CSPropertyHandler(PropertyHandler):
    def __init__(self, inputFile, c):
        PropertyHandler.__init__(self, inputFile, c)
        self.srcFile = None

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists(self.className + ".cs"):
                os.remove(self.className + ".cs")

    def startFiles(self):
        self.srcFile = open(self.className + ".cs", "w")
        self.srcFile.write(
            csPreamble % {"inputFile": self.inputFile, "classname": self.className}
        )

    def closeFiles(self):
        self.srcFile.write("    public static Property[][] validProps =\n")

        self.srcFile.write("    {\n")
        for s in self.sections:
            self.srcFile.write("        %sProps,\n" % s)
        self.srcFile.write("    };\n\n")

        self.srcFile.write("    public static string[] clPropNames =\n")
        self.srcFile.write("    {\n")
        for s in self.cmdLineOptions:
            self.srcFile.write('        "%s",\n' % s)
        self.srcFile.write("    };\n")
        self.srcFile.write("}\n")
        self.srcFile.close()

    def fix(self, propertyName):
        return propertyName.replace(".", r"\.").replace("[any]", r"[^\s]+")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        name = f"{self.currentSection}.{propertyName}"
        line = 'new(@"{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
            pattern=f"^{self.fix(name)}$" if usesRegex else name,
            usesRegex="true" if usesRegex else "false",
            defaultValue=f'"{defaultValue}"',
            deprecated="true" if deprecated else "false",
        )
        self.srcFile.write(f"         {line},\n")

    def newSection(self):
        self.srcFile.write(
            "    public static Property[] %sProps =\n" % self.currentSection
        )
        self.srcFile.write("    {\n")

    def closeSection(self):
        self.srcFile.write("    };\n")
        self.srcFile.write("\n")

    def moveFiles(self, location):
        dest = os.path.join(location, "csharp", "src", "Ice", "Internal")
        if os.path.exists(os.path.join(dest, self.className + ".cs")):
            os.remove(os.path.join(dest, self.className + ".cs"))
        shutil.move(self.className + ".cs", dest)


class JSPropertyHandler(PropertyHandler):
    def __init__(self, inputFile, c):
        PropertyHandler.__init__(self, inputFile, c)
        self.srcFile = None
        self.validSections = ["Ice"]

    def cleanup(self):
        if self.srcFile is not None:
            self.srcFile.close()
            if os.path.exists(self.className + ".js"):
                os.remove(self.className + ".js")

    def startFiles(self):
        self.srcFile = open(self.className + ".js", "w")
        self.srcFile.write(
            jsPreamble % {"inputFile": self.inputFile, "classname": self.className}
        )

    def closeFiles(self):
        self.srcFile.write("%s.validProps =\n" % (self.className))
        self.srcFile.write("[\n")
        for s in self.sections:
            if s in self.validSections:
                self.srcFile.write("    %s.%sProps,\n" % (self.className, s))
        self.srcFile.write("];\n\n")

        self.srcFile.write("%s.clPropNames =\n" % (self.className))
        self.srcFile.write("[\n")
        for s in self.cmdLineOptions:
            if s in self.validSections:
                self.srcFile.write('    "%s",\n' % s)
        self.srcFile.write("];\n")

        self.srcFile.write(jsEpilogue % {"classname": self.className})
        self.srcFile.close()

    def fix(self, propertyName):
        return propertyName.replace(".", "\\.").replace("[any]", ".")

    def propertyImpl(self, propertyName, usesRegex, defaultValue, deprecated):
        if self.currentSection in self.validSections:
            name = f"{self.currentSection}.{propertyName}"
            line = 'new Property("{pattern}", {usesRegex}, {defaultValue}, {deprecated})'.format(
                pattern=f"^{self.fix(name)}" if usesRegex else name,
                usesRegex="true" if usesRegex else "false",
                defaultValue=f'"{defaultValue}"',
                deprecated="true" if deprecated else "false",
            )
            self.srcFile.write(f"    {line},\n")

    def newSection(self):
        if self.currentSection in self.validSections:
            self.skipSection = False
            self.srcFile.write("%s.%sProps =\n" % (self.className, self.currentSection))
            self.srcFile.write("[\n")

    def closeSection(self):
        if self.currentSection in self.validSections:
            self.srcFile.write("];\n")
            self.srcFile.write("\n")

    def moveFiles(self, location):
        dest = os.path.join(location, "js", "src", "Ice")
        if os.path.exists(os.path.join(dest, self.className + ".js")):
            os.remove(os.path.join(dest, self.className + ".js"))
        shutil.move(self.className + ".js", dest)


class MultiHandler(PropertyHandler):
    def __init__(self, inputFile, c):
        self.handlers = []
        PropertyHandler.__init__(self, inputFile, c)

    def cleanup(self):
        for f in self.handlers:
            f.cleanup()

    def addHandlers(self, handlers):
        self.handlers.extend(handlers)

    def startFiles(self):
        for f in self.handlers:
            f.startFiles()

    def closeFiles(self):
        for f in self.handlers:
            f.closeFiles()

    def newSection(self):
        for f in self.handlers:
            f.newSection()

    def closeSection(self):
        for f in self.handlers:
            f.closeSection()

    def handleNewSection(self, sectionName, cmdLine):
        for f in self.handlers:
            f.handleNewSection(sectionName, cmdLine)

    def handleProperty(self, propertyName, usesRegex, default, deprecated):
        for f in self.handlers:
            f.handleProperty(propertyName, usesRegex, default, deprecated)

    def startElement(self, name, attrs):
        for f in self.handlers:
            f.startElement(name, attrs)

    def moveFiles(self, location):
        for f in self.handlers:
            f.moveFiles(location)


def main():
    if len(sys.argv) != 1 and len(sys.argv) != 3:
        usage()
        sys.exit(1)

    inFile = None
    lang = None

    #
    # Find the root of the tree.
    #
    for toplevel in [".", "..", "../..", "../../..", "../../../.."]:
        toplevel = os.path.normpath(toplevel)
        if os.path.exists(os.path.join(toplevel, "config", "makeprops.py")):
            break
    else:
        progError("cannot find top-level directory")
        sys.exit(1)

    if len(sys.argv) == 1:
        inFile = os.path.join(toplevel, "config", "PropertyNames.xml")
    else:
        option = sys.argv[1]
        if option == "--cpp":
            lang = "cpp"
        elif option == "--java":
            lang = "java"
        elif option == "--csharp":
            lang = "csharp"
        elif option == "--js":
            lang = "js"
        elif option in ["-h", "--help", "-?"]:
            usage()
            sys.exit(0)
        else:
            usage()
            sys.exit(1)
        inFile = sys.argv[2]

    className, ext = os.path.splitext(os.path.basename(inFile))
    global contentHandler
    if lang is None:
        contentHandler = MultiHandler(inFile, "")
        contentHandler.addHandlers(
            [
                CppPropertyHandler(inFile, className),
                JavaPropertyHandler(inFile, className),
                CSPropertyHandler(inFile, className),
                JSPropertyHandler(inFile, className),
            ]
        )
    else:
        if lang == "cpp":
            contentHandler = CppPropertyHandler(inFile, className)
        elif lang == "java":
            contentHandler = JavaPropertyHandler(inFile, className)
        elif lang == "csharp":
            contentHandler = CSPropertyHandler(inFile, className)
        elif lang == "js":
            contentHandler = JSPropertyHandler(inFile, className)

    #
    # Install signal handler so we can remove the output files if we are interrupted.
    #
    signal.signal(signal.SIGINT, handler)
    # signal.signal(signal.SIGHUP, handler)
    signal.signal(signal.SIGTERM, handler)
    initPropertyClasses(inFile)

    parser = make_parser()
    parser.setFeature(feature_namespaces, 0)
    parser.setContentHandler(contentHandler)
    pf = open(inFile)
    try:
        parser.parse(pf)
        contentHandler.moveFiles(toplevel)
    except IOError as ex:
        progError(str(ex))
        contentHandler.cleanup()
    except SAXException as ex:
        progError(str(ex))
        contentHandler.cleanup()


if __name__ == "__main__":
    main()
